"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createQueryTester = exports.createOperationTester = exports.createQueryOperation = exports.containsOperation = exports.numericalOperation = exports.numericalOperationCreator = exports.NopeOperation = exports.createEqualsOperation = exports.EqualsOperation = exports.createTester = exports.NestedOperation = exports.QueryOperation = exports.NamedGroupOperation = exports.BaseOperation = void 0;
const utils_1 = require("./utils");
/**
 * Walks through each value given the context - used for nested operations. E.g:
 * { "person.address": { $eq: "blarg" }}
 */
const walkKeyPathValues = (item, keyPath, next, depth, key, owner) => {
    const currentKey = keyPath[depth];
    // if array, then try matching. Might fall through for cases like:
    // { $eq: [1, 2, 3] }, [ 1, 2, 3 ].
    if ((0, utils_1.isArray)(item) && isNaN(Number(currentKey))) {
        for (let i = 0, { length } = item; i < length; i++) {
            // if FALSE is returned, then terminate walker. For operations, this simply
            // means that the search critera was met.
            if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {
                return false;
            }
        }
    }
    if (depth === keyPath.length || item == null) {
        return next(item, key, owner, depth === 0);
    }
    return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);
};
class BaseOperation {
    constructor(params, owneryQuery, options, name) {
        this.params = params;
        this.owneryQuery = owneryQuery;
        this.options = options;
        this.name = name;
        this.init();
    }
    init() { }
    reset() {
        this.done = false;
        this.keep = false;
    }
}
exports.BaseOperation = BaseOperation;
class GroupOperation extends BaseOperation {
    constructor(params, owneryQuery, options, children) {
        super(params, owneryQuery, options);
        this.children = children;
    }
    /**
     */
    reset() {
        this.keep = false;
        this.done = false;
        for (let i = 0, { length } = this.children; i < length; i++) {
            this.children[i].reset();
        }
    }
    /**
     */
    childrenNext(item, key, owner, root) {
        let done = true;
        let keep = true;
        for (let i = 0, { length } = this.children; i < length; i++) {
            const childOperation = this.children[i];
            if (!childOperation.done) {
                childOperation.next(item, key, owner, root);
            }
            if (!childOperation.keep) {
                keep = false;
            }
            if (childOperation.done) {
                if (!childOperation.keep) {
                    break;
                }
            }
            else {
                done = false;
            }
        }
        this.done = done;
        this.keep = keep;
    }
}
class NamedGroupOperation extends GroupOperation {
    constructor(params, owneryQuery, options, children, name) {
        super(params, owneryQuery, options, children);
        this.name = name;
    }
}
exports.NamedGroupOperation = NamedGroupOperation;
class QueryOperation extends GroupOperation {
    constructor() {
        super(...arguments);
        this.propop = true;
    }
    /**
     */
    next(item, key, parent, root) {
        this.childrenNext(item, key, parent, root);
    }
}
exports.QueryOperation = QueryOperation;
class NestedOperation extends GroupOperation {
    constructor(keyPath, params, owneryQuery, options, children) {
        super(params, owneryQuery, options, children);
        this.keyPath = keyPath;
        this.propop = true;
        /**
         */
        this._nextNestedValue = (value, key, owner, root) => {
            this.childrenNext(value, key, owner, root);
            return !this.done;
        };
    }
    /**
     */
    next(item, key, parent) {
        walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);
    }
}
exports.NestedOperation = NestedOperation;
const createTester = (a, compare) => {
    if (a instanceof Function) {
        return a;
    }
    if (a instanceof RegExp) {
        return b => {
            const result = typeof b === "string" && a.test(b);
            a.lastIndex = 0